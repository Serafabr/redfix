<!DOCTYPE html>
<html lang="en">
<head>
  <link
    rel="stylesheet"
    href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css"
    integrity="sha384-JcKb8q3iqJ61gNV9KGb8thSsNjpSL0n8PARn9HuZOnIxN0hoP+VmmDGMN5t9UJ0Z"
    crossorigin="anonymous"
  >
</head>
<body class="container w-50 text-justify">

<h1 class="text-center pt-5 font-weight-bold">API</h1>

<hr/>

<p>
  As funcionalidades básicas da aplicação são manipulações de dados,
  i.e. leitura, criação, edição e remoção de informações
  armazenadas no banco de dados. Essas ações são realizadas
  por meio de uma API exposta ao usuário em um endpoint
  <a href="https://graphql.org/">GraphQL</a> que é gerado pelo middleware
  <a href="https://www.graphile.org/postgraphile/introduction/">PostGraphile</a>
  no servidor.
</p>

<p>
  As queries e mutations que compõem a API correspondem a views e funções
  do schema (i.e. namespace) <code>api</code> do banco de dados.
  Detalhes sobre seus campos, inputs, outputs e data types podem ser
  consultados no ambiente
  <a href="http://localhost:3001/graphiql">GraphiQL</a>.
</p>

<p>
  A documentação sobre uploads foi colocada numa
  página exclusiva para esse assunto e pode ser acessada
  <a href="uploads.html">aqui</a>.
</p>

<p>
  O texto abaixo explica um pouco das ideias que nortearam
  a criação da API e seu modelo de dados subjacente,
  tentando mostrar como eles aderem aos requisitos e funcionalidades
  da aplicação e como podem ser usados pelo frontend.
</p>

<p class="alert alert-dark" role="alert">
  OBS 1: Neste texto usa-se <code>snake_case</code> para os nomes dos
  objetos do banco de dados, o mesmo padrão usado nos seus respectivos códigos-fonte.
  Na API GraphQL, esses nomes aparecem em <code>camelCase</code>.
</p>

<div class="alert alert-dark" role="alert">
  OBS 2: Neste texto foi dado enfoque nas mutations. Para as queries,
  bastam os seguintes comentários:
  <ul>
    <li>
      Em geral, as queries da API correspondem a <b>views</b> do schema
      <code>api</code> e possuem o sufixo <code>_data</code> em seus nomes
      (e.g. <code>task_data</code>).
      Queries que necessitam obrigatoriamente de uma condição (input)
      para serem executadas correspondem a <b>funções</b>, também do schema
      <code>api</code>, e têm nomes
      prefixados por <code>get_</code> (e.g. <code>get_asset_children</code>).
    </li>
    <li>
      Os campos com nomes no plural (e.g. campos <code>assets</code>
      e <code>supplies</code> na view <code>task_data</code>,
      campo <code>tasks</code> na view <code>asset_data</code> etc.)
      possuem data type <code>JSON</code>
      e correspondem a listas de entidades
      vinculadas à entidade principal (a entidade que dá o nome à view).
      Quando não houver entidades vinculadas (por exemplo, no caso de uma tarefa
      sem suprimentos), esse campo retorna um array vazio
      (e não <code>null</code>).
    </li>
    <li>
      Embora tenham sido utilizados padrões que tendem a acelerar a execução da queries,
      quase sempre são necessárias muitas operações de <code>join</code>,
      o que pode resultar em má performance do banco de dados
      nas consultas a tabelas muito grandes.
      Outras estratégias para reduzir o tempo de resposta
      poderão ser necessárias futuramente e serão estudadas e aplicadas
      conforme houver necessidade.
    </li>
    <li>
      Queries e campos para uso em formulários
      (e.g. lista das possíveis categorias de uma nova tarefa)
      possuem o sufixo <code>_options</code> em seus nomes.
    </li>
  </ul>
</div>

<div class="alert alert-dark" role="alert">
  OBS 3: Buscou-se minimizar a quantidade de operações incluídas em cada mutation,
  com as seguintes vantagens:
  <ul>
    <li>interfaces mais simples e fáceis de compreender</li>
    <li>menor quantidade de inputs em cada mutation</li>
    <li>desenvolvimento mais rápido do frontend</li>
    <li>melhor experiência do usuário</li>
    <li>melhor performance do banco de dados nas operações de escrita</li>
    <li>menor necessidade de triggers</li>
  </ul>
</div>

<h3 class="text-center font-weight-bold">Ativo</h3>
<h3 class="text-center font-weight-bold"><code>database/api/asset</code></h3>

<p>
  <h4>Categorias de ativos</h4>
  As categorias de ativos têm duas funções: servem para classificar os ativos
  (i.e. pertencem à tabela de referência <code>asset_categories</code>),
  e funcionam como qualquer outro ativo
  (i.e. pertencem também à tabela <code>assets</code>),
  mas com a característica especial de estar no topo de
  uma hierarquia de ativos (i.e. nunca aparecem como ativo-filho na tabela
  <code>asset_parents</code>).
  São consideradas 4 categorias de ativos: (1) sistema de endereçamento
  (edifícios, áreas, espaços etc.); (2) sistema elétrico; (3) sistema de
  climatização; e (4) sistema hidráulico.
</p>

<p>
  <h4>Localização</h4>
  Todo ativo deve possuir uma localização. Tal dado está contido
  na própria tabela <code>assets</code>, na coluna <code>location_id</code>,
  devendo referenciar-se à id de um ativo que seja da categoria
  "sistema de endereçamento". Essa verificação é feita pelo trigger
  <code>check_asset_location</code>
  sempre que um ativo for criado ou mofificado.  
</p>

<p>
  <h4>Hierarquias</h4>
  Como foi dito, cada categoria de ativos forma uma hierarquia distinta.
  Para evitar queries muito demoradas, a API não possui
  queries que retornam a árvore inteira de ativos. A ideia é que o usuário
  possa "investigar" a hierarquia de ativos passo a passo, usando as queries
  <code>get_asset_children</code> e
  <code>get_asset_parents</code>, em que são retornados, respectivamente,
  apenas os ativos filhos e pais <b>diretamente</b> vinculados a um determinado ativo.
  Há mutations específicas para definir essas hierarquias,
  vinculando (ou desvinculando) um filho ou um pai a um ativo:
  <code>insert_asset_parent</code>,
  <code>insert_asset_child</code>,
  <code>remove_asset_parent</code>,
  <code>remove_asset_child</code>.
</p>

<p>
  <h4>Tags</h4>
  O usuário poderá criar, editar e deletar tags (<code>insert_tag</code>,
  <code>modify_tag</code> e <code>remove_tag</code>), e vinculá-las ou desvinculá-las aos ativos
  (<code>insert_asset_tag</code> e <code>remove_asset_tag</code>).
</p>

<p>
  <h4>Criação de um ativo</h4>
  <code>insert_asset</code> é uma operação cujos inputs 
  correspondem às colunas da tabela <code>assets</code>. O mesmo vale para a mutation
  <code>modify_assets</code>.
  Vincular tags, ativos pais, ativos filhos etc. é feito posteriormente,
  por meio de outras mutations em outros formulários.
</p>

<h3 class="text-center font-weight-bold">Planos de Manutenção</h3>
<h3 class="text-center font-weight-bold"><code>database/api/plan</code></h3>

<p>
  <h4>Grupos de ativos</h4>
  Os planos de manutenção somente podemo ser vinculados a grupos de ativos.
  As mutations 
  <code>insert_bundle</code>,
  <code>modify_bundle</code>,
  <code>insert_bundle_asset</code> e
  <code>remove_bundle_asset</code>
  servem para criar e editar essas entidades.
</p>

<p>
  <h4>Planos de manutenção</h4>
  O usuário pode utilizar as mutations
  <code>insert_plan</code> e
  <code>modify_plan</code>
  para criar e editar um plano de manutenção.
  <code>insert_bundle_plan</code> serve para vincular um plano a um grupo de ativos.
</p>

<h3 class="text-center font-weight-bold">Dashboard</h3>
<h3 class="text-center font-weight-bold"><code>database/api/dashboard</code></h3>

<p>
  A tabela <code>dashboard</code> é populada automaticamente por uma cronjob
  no servidor. A ideia é inserir uma linha por dia, com dados
  agregados (e.g. quantidade de tarefas atrasadas, total de ativos cadastrados etc.)
  que permitam uma análise da evolução da manutenção.
  Essa tabela pode ser modificada livremente para absorver novas estatísticas.
  O acesso aos dados é feito através da view <code>dashboard_data</code>.
</p>

<h3 class="text-center font-weight-bold">Estoques</h3>
<h3 class="text-center font-weight-bold"><code>database/api/depot</code></h3>

<p>
  <h4>Criação e modificação de um estoque</h4>
  A operação <code>insert_depot</code>
  inclui apenas campos da tabela <code>depots</code> (nome da empresa,
  objeto, data de vencimento,
  tipo de estoque etc.). O "tipo de estoque" deve ser um dentre os existentes na tabela
  de referência <code>depot_categories</code>
  (processo de licitação, contrato ou ARP).
  Atualizações em um estoque podem ser feitas com a mutation
  <code>modify_depot</code>, o que permite transformar um processo de licitação
  em contrato ou alterar a data de vencimento de um contrato que foi prorrogado.
  Isso permite que a aplicação esteja consistente com a evolução real dos estoques
  da manutenção.
</p>

<p>
  <h4>Criação de uma caixa e seus suprimentos</h4>
  Uma caixa é um conjunto de suprimentos válido apenas
  por uma fração do período de vigência do estoque.
  Exemplos: após um aditivo, os preços podem ser majorados;
  após uma prorrogação o quantitativo inicial de cada material é "reinicializado".
  Portanto, a mutation <code>insert_box</code> serve justamente para isso:
  criar uma cesta de suprimentos de um determinado estoque, com os preços e
  quantitativos iniciais vigentes em um determinado período.
  Nessa mutation, o usuário pode (opcionalmente) indicar uma caixa já existente
  como "modelo" (input <code>box_id</code>). Com isso,
  ao criar a caixa, automaticamente são copiados os suprimentos da caixa "modelo"
  para dentro da nova caixa. Em seguida, o usuário pode ajustar os preços
  e quantitativos de cada suprimento individualmente,
  com a mutation <code>modify_supply</code>.
  Alternativamente, caso <code>insert_box</code> tenha sido executada com
  <code>box_id = null</code>, o usuário deverá criar os suprimentos
  da nova caixa um por um, com a mutation <code>insert_supply</code>.
  Correções podem ser feitas com <code>modify_supply</code> e
  <code>remove_supply</code>. Registre-se que a remoção não será permitida
  caso o suprimento esteja vinculado a alguma tarefa finalizada. Tal checagem é
  feita pelo trigger <code>check_delete_supply</code>.
  Se não houver esse impedimento, o suprimento é efetivamente apagado do banco de dados,
  bem como seus eventuais vínculos a tarefas.
</p>

<p>
  <h4>Ativar ou desativar uma caixa</h4>
  As mutations 
  <code>activate_box</code> e <code>deactivate_box</code>
  permitem incluir ou retirar caixas da tabela <code>active_boxes</code>,
  que é uma lista de caixas com os suprimentos que podem ser vinculados
  a uma tarefa. Em outras palavras, somente os suprimentos de caixas ativas
  aparecerão como opções passíveis de inclusão, pelo usuário, em uma tarefa.
  Essas operações servem para dar dinamismo e flexibilidade à aplicação
  e evita o acúmulo ilimitado de opções nos formulários.
  Seguem abaixo alguns exemplos de situações em que essas mutations são úteis:
  <ul>
    <li>
      O usuário pode cadastrar suprimentos
      de um edital de licitação sem que eles apareçam como disponíveis para vínculo
      a uma tarefa (o usuário criou um estoque, uma caixa e seus suprimentos, mas nunca
      executou <code>activate_box</code> para essa caixa).
    </li>
    <li>
      Necessidade de duas caixas ativas, onde poderão ser usados
      suprimentos com um preço antigo nas tarefas até determinada data,
      mas já sendo possível vincular suprimentos com o novo preço no planejamento
      de tarefas futuras.
    </li>
    <li>
      Cadastro paulatino de suprimentos, sem que estes sejam "vinculáveis" a uma
      tarefa antes de uma verificação completa de que todos foram cadastrados
      corretamente (o usuário pode cadastrar centenas de suprimentos ao longo de
      vários dias e somente após uma verificação completa ele executa
      <code>activate_box</code>).
    </li>
    <li>
      Fim da vigência de um contrato, impossibilitando o uso de seus suprimentos
      em futuras tarefas (<code>deactivate_box</code> foi executada para todas as
      caixas de tal contrato e então seus suprimentos não mais aparecem
      nos formulários).
    </li>
    <li>
      Cadastro de materiais de uma nota fiscal, a serem fornecidos no âmbito de
      algum contrato de manutenção (duas caixas ativas, a dos materiais e serviços
      incluídos no contrato e dos materias da nota fiscal).
    </li>
  </ul>
</p>

<h3 class="text-center font-weight-bold">Projeto</h3>
<h3 class="text-center font-weight-bold"><code>database/api/project</code></h3>

<p>
  <h4>Criação, modificação, remoção de um projeto</h4>
  Essas operações correspondem às mutations
  <code>insert_project</code>, <code>modify_project</code>,
  <code>remove_project</code>. Deletar um projeto efetivamente 
  o apaga do banco de dados, e tem o efeito em cascata de setar
  a coluna <code>project_id</code> para <code>null</code> em todas
  as tarefas que porventura estivessem vinculadas ao projeto removido.
</p>

<p>
  <h4>Desativar um contrato</h4>
  Com as mutations <code>activate_project</code> e <code>deactivate_project</code>
  os usuários podem definir quais projetos estão "vigentes", ou seja, são atuais
  opções para possuir novas tarefas vinculadas a eles.
</p>

<p>
  <h4>Vincular uma tarefa a um projeto</h4>
  As mutations <code>add_task_to_project</code> e <code>remove_task_from_project</code>
  permitem gerenciar quais tarefas fazem parte de um projeto (por meio da tela, no frontend,
  da entidade projeto).
  Alternativamente, o usuário pode vincular uma tarefa a um projeto por meio da tela e
  formulários da entidade tarefa (e suas mutations <code>insert_task</code> e
  <code>modify_task</code>).
</p>

<h3 class="text-center font-weight-bold">Especificação Técnica</h3>
<h3 class="text-center font-weight-bold"><code>database/api/spec</code></h3>

<p>
  <h4>Criar uma especificação totalmente nova</h4>
  Com a mutation <code>insert_spec</code>.
  O usuário deve escolher uma <code>spec_sf</code> no formato SF-xxxxx.
</p>

<p>
  <h4>Criar uma versão nova de uma especificação existente</h4>
  A mutation <code>insert_spec_version</code> funciona da seguinte maneira:
  o usuário deve definir apenas qual a nova string
  do atributo <code>version</code> (todos os outros atributos são copiados
  da versão usada como modelo a ser copiado).
  Também são copiados os metadados dos arquivos, não sendo necessário fazer
  novos uploads. O usuário pode, em seguida, atualizar os campos desejados
  da especificação técnica usando a mutation <code>modify_spec_version</code>.
</p>

<p>
  <h4>Adicionar e remover arquivos</h4>
  As operações de adição e remoção de arquivos
  (i.e., inserção de metadados dos uploads vinculados
  a especificações técnicas) é feita com as mutations
  <code>insert_spec_files</code> e <code>remove_spec_file</code>.
</p>

<p>
  <h4>Preços</h4>
  Os preços pesquisados para as especificações técnicas podem ser incluídos
  e alterados com as mutations <code>insert_price</code> e <code>modify_price</code>.
</p>

<h3 class="text-center font-weight-bold">Tarefa</h3>
<h3 class="text-center font-weight-bold"><code>database/api/task</code></h3>

<p>
  <h4>Eventos da tarefa</h4>
  São adicionados eventos à tabela <code>task_events</code>
  sempre que ocorrer:
  <ul>
    <li>a criação de uma tarefa (<code>insert_task</code>)</li>
    <li>a atualização de uma tarefa (<code>modify_task</code>)</li>
    <li>o envio a uma outra equipe (<code>send_task</code>)</li>
    <li>o recebimento (<code>receive_task</code>)</li>
    <li>o cancelamento do envio (<code>cancel_send_task</code>)</li>
    <li>o acréscimo de uma mensagem (<code>insert_task_note</code>)</li>
    <li>a alteração do status (<code>move_task</code>)</li>
  </ul>
  As mensagens podem ser alteradas por meio de <code>modify_task_note</code>,
  sem gerar um novo evento. A remoção de uma mensagem (<code>remove_task_note</code>)
  apenas coloca <code>is_visible</code> do evento (nota) como <code>false</code>,
  sem deletar dados.
</p>

<p>
  <h4>Ativos de uma tarefa</h4>
  Cada tarefa deve estar vinculada a pelo menos um ativo,
  que devem ser selecionados no momento de sua criação.
  É possível adicionar e remover ativos depois da criação da tarefa,
  por meio de <code>insert_task_asset</code> e <code>remove_task_asset</code>.
</p>

<p>
  <h4>Suprimentos de uma tarefa</h4>
  Apesar de que somente suprimentos de caixas ativas são disponibilizados
  nos formulários, há um trigger, denominado <code>check_insert_active_box</code>,
  que faz essa checagem antes de inserir uma nova linha na tabela
  <code>task_supplies</code>.
  A adição e remoção de um suprimento em uma tarefa são feitas por meio das mutations
  <code>insert_task_supply</code> e <code>remove_task_supply</code>. A quantidade de
  um suprimento já vinculado a uma tarefa pode ser feita com
  <code>modify_task_supply</code>.
</p>

<p>
  <h4>Arquivos</h4>
  Aplica-se a mesma lógica de upload de arquivos já detalhada para as
  especificações técnicas. As mutations são
  <code>insert_task_files</code> e
  <code>remove_task_file</code>.
</p>

<h3 class="text-center font-weight-bold">Equipe</h3>
<h3 class="text-center font-weight-bold"><code>database/api/team</code></h3>

<div class="alert alert-dark" role="alert">
  Detalhes sobre os distintos papéis dos usuários ("roles") podem ser vistos
  <a href="roles.html">aqui</a>.
</div>

<p>
  <h4>Contas de usuários</h4>
  Novas contas de usuários podem ser criadas e editadas por usuários
  <code>supervisor</code>s, <code>coordinator</code>s, ou <code>administrator</code>s,
  usando <code>insert_person</code> e <code>modify_person</code>.
  Essas mutations permitem setar o nível de acesso (role) do usuário.
  O próprio usuário pode modificar seus dados e senha por meio de
  <code>modify_self</code> e <code>change_password</code>,
  sem poder escolher outro nível de acesso.
</p>  

<p>
  <h4>Criação e edição de equipes</h4>
  Novas equipes podem ser criadas e editadas por usuários
  <code>supervisor</code>s, <code>coordinator</code>s ou <code>administrator</code>s,
  usando as mutations <code>insert_team</code> e <code>modify_team</code>.
  Equipes podem ser ativadas e desativadas com <code>activate_team</code> e
  <code>deactivate_team</code>. Pessoas podem ser adicionadas a equipes
  com as mutations <code>insert_team_person</code> e <code>remove_team_person</code>.
  As mutations <code>activate_person</code> e <code>deactivate_person</code>
  tem utilidade similar às correspondentes para projetos e caixas. Conforme dito, essas
  mutations servem para que o sistema considere em seus formulários (para
  adição de alguém a uma equipe, por exemplo) apenas os usuários que de fato
  estão de fato utilizando a aplicação.
</p>

</body>
</html>
